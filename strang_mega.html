<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STRANG Unified Field (Optimized)</title>
    <style>
        @import url('https://fonts.cdnfonts.com/css/din-pro');
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;500&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #e6e6e6;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* CONTAINER: Fits the physical screen exactly */
        .screen-wrapper {
            width: 100%; 
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: #fdfdfd; 
        }

        /* LAYER 1: WEBGL CANVAS */
        #furCanvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* LAYER 2: UI OVERLAY */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        .corner-text {
            position: absolute;
            font-family: "Roboto Mono", monospace;
            font-size: 42px;
            color: #222222;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 500;
            display: none; /* Hidden by default, revealed by JS */
        }

        /* Positioning relative to the LOCAL screen */
        .top-left { top: 60px; left: 60px; }
        .bottom-left { bottom: 60px; left: 60px; }
        .top-right { top: 60px; right: 60px; text-align: right; }
        .bottom-right { bottom: 60px; right: 60px; text-align: right; }

        /* CENTER SCREEN */
        .center-logo-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            display: none; /* Hidden by default */
        }

        .mega-logo {
            width: 60%; 
            filter: brightness(0) invert(0);
            mix-blend-mode: difference;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div class="screen-wrapper">
        <canvas id="furCanvas"></canvas>
        
        <div class="ui-layer">
            <div class="corner-text top-left" id="ui-brand">STRANG.DESIGN</div>
            <div class="corner-text bottom-left" id="ui-city">MIAMI</div>

            <div class="center-logo-container" id="ui-logo">
                <img class="mega-logo" src="assets/strang_logo.png" alt="STRANG">
            </div>

            <div class="corner-text top-right" id="timer">00:00:00:0</div>
            <div class="corner-text bottom-right" id="weather">LOADING...</div>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    // The "Virtual" Total Resolution (The Field)
    const TOTAL_W = 6480;
    const TOTAL_H = 3840;
    // The "Physical" Single Screen Resolution
    const SCREEN_W = 2160;
    const SCREEN_H = 3840;

    const DENSITY = 30;  
    const LENGTH = 200;  
    const COLOR = '#222222';

    // 1. DATA LOGIC (Time & Weather)
    const timerEl = document.getElementById('timer');
    const weatherEl = document.getElementById('weather');

    function updateTime() {
        const now = new Date();
        const estTime = new Intl.DateTimeFormat('en-US', {
            timeZone: 'America/New_York',
            hour12: false,
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        }).format(now);
        timerEl.innerText = estTime + ":" + Math.floor(now.getMilliseconds()/100);
        requestAnimationFrame(updateTime);
    }

    async function fetchWeather() {
        try {
            const response = await fetch('https://api.open-meteo.com/v1/forecast?latitude=25.7617&longitude=-80.1918&current_weather=true&temperature_unit=fahrenheit');
            const data = await response.json();
            if (data.current_weather) {
                weatherEl.innerText = `${Math.round(data.current_weather.temperature)}Â°F`;
            }
        } catch (e) { weatherEl.innerText = "OFFLINE"; }
    }

    // 2. WEBGL LOGIC (OPTIMIZED)
    let scene, camera, renderer, linesMesh, positions, fadeMesh;
    const urlParams = new URLSearchParams(window.location.search);
    const screenID = urlParams.get('screen') || 'center'; 

    function initWebGL() {
        const canvas = document.getElementById('furCanvas');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfdfdfd);

        // --- OPTIMIZATION: CAMERA OFFSET ---
        // We create a camera that thinks it sees the whole world (TOTAL_W),
        // but we force it to only render a specific window (SCREEN_W).
        
        camera = new THREE.OrthographicCamera(0, TOTAL_W, 0, TOTAL_H, 1, 1000);
        camera.position.z = 10;

        let offsetX = 0;
        if (screenID === 'center') offsetX = 2160;
        if (screenID === 'right')  offsetX = 4320;

        // ( fullWidth, fullHeight, x, y, width, height )
        camera.setViewOffset(TOTAL_W, TOTAL_H, offsetX, 0, SCREEN_W, SCREEN_H);
        camera.updateProjectionMatrix();

        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: false,
            preserveDrawingBuffer: true, // Needed for trails
            powerPreference: "high-performance"
        });
        
        // Cap Pixel Ratio at 2 to save GPU on 4K screens
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight); // Fill the local window
        renderer.autoClear = false;

        // --- GLOBAL GEOMETRY ---
        // We calculate points for the FULL 6480px width so the waves flow seamlessly
        const cols = Math.floor(TOTAL_W / DENSITY);
        const rows = Math.floor(TOTAL_H / DENSITY);
        const totalLines = cols * rows;

        const geometry = new THREE.BufferGeometry();
        positions = new Float32Array(totalLines * 2 * 3);

        let i = 0;
        for (let x = 0; x < TOTAL_W; x += DENSITY) {
            for (let y = 0; y < TOTAL_H; y += DENSITY) {
                positions[i] = x; positions[i+1] = y; positions[i+2] = 0;
                positions[i+3] = x; positions[i+4] = y; positions[i+5] = 0;
                i += 6;
            }
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.LineBasicMaterial({ color: new THREE.Color(COLOR) });
        linesMesh = new THREE.LineSegments(geometry, material);
        scene.add(linesMesh);

        // FADE LAYER (Must cover total area to work with the camera offset)
        const fadeGeo = new THREE.PlaneGeometry(TOTAL_W, TOTAL_H);
        fadeGeo.translate(TOTAL_W/2, TOTAL_H/2, 0);
        const fadeMat = new THREE.MeshBasicMaterial({ color: 0xfdfdfd, transparent: true, opacity: 0.2 });
        fadeMesh = new THREE.Mesh(fadeGeo, fadeMat);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // SYNC TIME: Uses system clock so all screens match instantly
        const now = Date.now();
        const syncTime = now * 0.0003; 

        const posArray = linesMesh.geometry.attributes.position.array;
        const total = positions.length / 6;
        let pIndex = 0;

        // ANIMATION LOOP
        for (let k = 0; k < total; k++) {
            const x = posArray[pIndex];
            const y = posArray[pIndex + 1];

            // Wave Math
            const angle = (Math.cos(x * 0.0005 + syncTime) + Math.sin(y * 0.0015 + syncTime)) * Math.PI;

            posArray[pIndex + 3] = x + Math.cos(angle) * LENGTH;
            posArray[pIndex + 4] = y + Math.sin(angle) * LENGTH;
            pIndex += 6;
        }
        linesMesh.geometry.attributes.position.needsUpdate = true;
        
        renderer.render(fadeMesh, camera);
        renderer.render(scene, camera);
    }

    // 3. UI MANAGEMENT
    function setupUI() {
        // Hide everything first
        document.getElementById('ui-brand').style.display = 'none';
        document.getElementById('ui-city').style.display = 'none';
        document.getElementById('ui-logo').style.display = 'none';
        document.getElementById('timer').style.display = 'none';
        document.getElementById('weather').style.display = 'none';

        // Show only what fits this screen
        if (screenID === 'left') {
            document.getElementById('ui-brand').style.display = 'block';
            document.getElementById('ui-city').style.display = 'block';
        }
        if (screenID === 'center') {
            document.getElementById('ui-logo').style.display = 'flex';
        }
        if (screenID === 'right') {
            document.getElementById('timer').style.display = 'block';
            document.getElementById('weather').style.display = 'block';
        }
    }

    function onWindowResize() {
        // Update renderer size to fill the local window
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Note: We do NOT update camera ViewOffset here because 
        // in installation mode, the resolution is fixed to the hardware (4k).
    }

    window.addEventListener('load', () => {
        setupUI();
        updateTime();
        fetchWeather();
        initWebGL();
        animate();
    });
    window.addEventListener('resize', onWindowResize);

</script>
</body>
</html>
